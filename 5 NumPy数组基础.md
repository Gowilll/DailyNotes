# Markdown 基础语法速查表

| 功能         | 语法示例                                             | 显示效果                         |
|--------------|------------------------------------------------------|----------------------------------|
| **标题**     | `# 一级标题`<br>`## 二级标题`<br>`### 三级标题`       | 一级标题<br>二级标题<br>三级标题 |
| **加粗**     | `**加粗**`                                            | **加粗**                         |
| **斜体**     | `*斜体*`                                              | *斜体*                           |
| **加粗+斜体**| `***加粗斜体***`                                      | ***加粗斜体***                   |
| **删除线**   | `~~删除线~~`                                          | ~~删除线~~                       |
| **引用**     | `> 引用内容`<br>`>> 嵌套引用`                          | > 引用内容<br>> 嵌套引用         |
| **无序列表** | `- 项目1`<br>`- 项目2`                                | - 项目1<br>- 项目2              |
| **有序列表** | `1. 第一项`<br>`2. 第二项`                             | 1. 第一项<br>2. 第二项           |
| **链接**     | `[点击这里](https://example.com)`                    | [点击这里](https://example.com) |
| **图片**     | `![描述](https://example.com/image.jpg)`             | 显示图片                         |
| **行内代码** | `` `代码` ``                                          | `代码`                           |
| **代码块**   | \`\`\`python<br>print("Hello")<br>\`\`\`             | 格式化代码块                     |
| **分割线**   | `---` 或 `***`                                        | ---（分割线）                   |
| **表格**     | `|列1|列2|`<br>`|--|--|`<br>`|A|B|`                   | 表格形式                         |
| **任务列表** | `- [ ] 未完成`<br>`- [x] 已完成`                      | - [ ] 未完成<br>- [x] 已完成     |
| **转义字符** | `\*不强调\*`                                          | \*不强调\*（显示星号）          |

---
一、换行
- **段落换行**：空一行（即按两次 Enter）
- **强制换行**：在行尾加两个空格再按 Enter  
- **使用 `<br>` 标签**：适用于 HTML 语法  
二、目录
- [换行说明](#换行说明github-中换行问题)
- [Markdown 基础语法](#markdown-基础语法一览表)
- [GitHub 特性](#github-markdown-独有功能)

---

## 📘 目录  
 [★ NumPy数组的属性](#NumPy数组的属性)  
 [★ 数组索引：获取单个元素](#数组索引：获取单个元素)  
 [★ 数组切片：获取子数组](#数组切片：获取子数组)  
 [★ 数组的变形](#数组的变形)  
 [★ 数组拼接和拆分](#数组拼接和拆分)  

---
> 数组的属性  
>   确认数组的大小、形状、内存消耗和数据类型  
> 数组的索引  
>   获取和设置数组各个元素的值  
> 数组的拆分  
>   在大的数组中获取或设置下更小的子数组  
> 数组的变形  
>   改变给定数组的形状  
> 数组的连接和拆分  
>   将多个数组合并为一个，以及将一个数组拆分为多个


---
## NumPy数组的属性

种子值：Numpy的随机数生成器可以设置一组种子值，以确保每次程序执行时都可以生成*同样的随机数组*

```python
In [1]: import numpy as np

In [2]: rng = np.random.default_rng(seed=1701) # seed 设置随机种子数

In [3]: x1 = rng.integers(10, size=6) # 一维数组

In [4]: x2 = rng.integers(10, size=(3, 4)) # 二维数组

In [5]: x3 = rng.integers(10, size=(3, 4, 5)) # 三维数组

In [6]: print("x3 ndim: ", x3.ndim) # ndim 数组的维数
x3 ndim:  3

In [7]: print("x3 shape: ", x3.shape) # shape 数组每个维度的大小
x3 shape:  (3, 4, 5)

In [8]: print("x3 size: ", x3.size) # size数组的总大小
x3 size:  60

In [9]: print("dtype: ", x3.dtype) # dtype 每个元素的类型
dtype:  int64

```

## 数组索引：获取单个元素
> 和Python列表一样，在一维数组中也可以通过在中括号中指定索引来获取第i个值（从0开始计数）

---
```python
In [10]: x1
Out[10]: array([9, 4, 0, 3, 8, 6])

In [11]: x1[0] # 第一个元素
Out[11]: np.int64(9)

In [12]: x1[4]
Out[12]: np.int64(8)

In [13]: x1[-1] # 倒数第1个元素，末尾索引[-1]
Out[13]: np.int64(6)

In [14]: x1[-2]
Out[14]: np.int64(8)

In [15]: x2
Out[15]:
array([[3, 1, 3, 7],
       [4, 0, 2, 3],
       [0, 0, 6, 9]])

In [16]: x2[0, 0] # 第一行第一列的元素，二维数组[行, 列]
Out[16]: np.int64(3)

In [17]: x2[2, 0]
Out[17]: np.int64(0)

In [18]: x2[2, -1]
Out[18]: np.int64(9)

In [19]: x2[0, 0] = 12 # 用索引修改元素值

In [19]: x2
Out[19]:
array([[12,  1,  3,  7],
       [ 4,  0,  2,  3],
       [ 0,  0,  6,  9]])

In [20]: x1[0] = 3.14159 # numpy数组是固定类型，3.14159被截断成3

In [20]: x1
Out[20]: array([3, 4, 0, 3, 8, 6])

```
> 注意，Numpy是固定类型，这意味着你试图将一个浮点值插入一个整形数组时，浮点值会被截断成整型，并且这种截断是自动完成的，不会给你任何警告。

## 数组切片：获取子数组
> 使用切片获取子数组，切片(slice)符号用":"表示。语法与Python中的类似  
> x[start:stop:step]  
> 缺省值：start＝0、stop＝<维度的大小>、step＝1  

### a.一维数组

```python
In [21]: x1
Out[21]: array([3, 4, 0, 3, 8, 6])

In [22]: x1[:3] # 获取前三个元素
Out[22]: array([3, 4, 0])

In [23]: x1[3:] # 获取索引3之后的元素，包括索引3
Out[23]: array([3, 8, 6])

In [24]: x1[1:4] # 中间的子数组
Out[24]: array([4, 0, 3])

In [25]: x1[::2] # 偶数索引元素
Out[25]: array([3, 0, 8])

In [26]: x1[1::2] # 奇数索引元素
Out[26]: array([4, 3, 6])

In [27]: x1[::-1] # 将所有元素逆序排列
Out[27]: array([6, 8, 3, 0, 4, 3])

In [28]: x1[4::-2] # 从索引4开始每隔一个元素进行逆序排列
Out[28]: array([8, 0, 3])

```
步长值为负数时，start参数和stop参数的默认值被互换。因此这是一个非常方便的反转数组方式。

### b.多维子数组

```python
In [54]: x2
Out[54]:
array([[12,  1,  3,  7],
       [ 4,  0,  2,  3],
       [ 0,  0,  6,  9]])

In [55]: x2[:2, :3] # 获取前两行，前三列
Out[55]:
array([[12,  1,  3],
       [ 4,  0,  2]])

In [56]: x2[:3, ::2] # 获取前三行，偶数列（列也是从0开始计数）
Out[56]:
array([[12,  3],
       [ 4,  2],
       [ 0,  6]])

In [57]: x2[::1, ::-1] # 所有行和列，逆序排列
Out[57]:
array([[ 7,  3,  1, 12],
       [ 3,  2,  0,  4],
       [ 9,  6,  0,  0]])

In [58]: x2[:, 0] # 获取第一列
Out[58]: array([12,  4,  0])

In [59]: x2[0, :] # 获取第一行
Out[59]: array([12,  1,  3,  7])

In [60]: x2[0] # 等同于 x2[0, :]
Out[60]: array([12,  1,  3,  7])

```

上面使用一个":"表示空切片

### c.非副本视图的子数组
> Numpy数组切片返回的是数组数据的视图，而不是数据的副本。

```python
In [61]: print(x2)
[[12  1  3  7]
 [ 4  0  2  3]
 [ 0  0  6  9]]

In [62]: x2_sub = x2[:2, :2] # 从中抽取一个2x2的子数组

In [63]: print(x2_sub)
[[12  1]
 [ 4  0]]

# 如果修改这个子数组，原始数组也会被修改
In [64]: x2_sub[0, 0] = 99

In [65]: print(x2_sub)
[[99  1]
 [ 4  0]]

In [66]: print(x2)
[[99  1  3  7]
 [ 4  0  2  3]
 [ 0  0  6  9]]

```

这种通过子数组修改原始数组的方法非常有用，在处理非常大的数据集时，可以获取并处理这些数据集的片段，而不用复制底层的数据缓存。

### d.创建数组的副本
> 仅管数组视图有一些非常好的特性，但是有时候明确的复制数组里的数据或子数组也是非常有用的。可以简单的通过`copy()`方法来实现

```python

In [79]: x2_sub_copy = x2[:2, :2].copy()

In [80]: print(x2_sub_copy)
[[99  1]
 [ 4  0]]

In [81]: x2_sub_copy[0, 0] = 42

In [82]: print(x2)
[[99  1  3  7]
 [ 4  0  2  3]
 [ 0  0  6  9]]

In [83]:

In [83]:

In [83]: grid = np.arange(1, 10).reshape(3 3)

In [84]: print(grid)
[[1 2 3]
 [4 5 6]
 [7 8 9]]

In [85]: x = np.array([1, 2, 3])

In [86]: x.reshape((1, 3))
Out[86]: array([[1, 2, 3]])

In [87]: x.reshape((3, 1))
Out[87]:
array([[1],
       [2],
       [3]])

In [88]: x[np.newaxis, :]
Out[88]: array([[1, 2, 3]])

In [89]: x[:,np.newaxis]
Out[89]:
array([[1],
       [2],
       [3]])

In [90]:

In [90]:

In [90]:

In [90]: x = np.array([1, 2, 3])

In [91]: y = np.array([3, 2, 1])

In [92]: np.concatenate([x, y])
Out[92]: array([1, 2, 3, 3, 2, 1])

In [93]: z = np.array([99, 99, 99])

In [94]: print(np.concatenate([x, y, z]))
[ 1  2  3  3  2  1 99 99 99]

In [95]: grid = np.array([[1, 2, 3],
    ...:                 [4, 5, 6]])

In [96]: np.concatenate([grid, grid])
Out[96]:
array([[1, 2, 3],
       [4, 5, 6],
       [1, 2, 3],
       [4, 5, 6]])

In [97]: np.concatenate([grid, grid], axis=1)
Out[97]:
array([[1, 2, 3, 1, 2, 3],
       [4, 5, 6, 4, 5, 6]])

In [98]: np.vstack([x, grid])
Out[98]:
array([[1, 2, 3],
       [1, 2, 3],
       [4, 5, 6]])

In [99]: y = np.array([[99],
    ...:              [99]])

In [100]: np.hstack([grid, y])
Out[100]:
array([[ 1,  2,  3, 99],
       [ 4,  5,  6, 99]])

In [101]:

In [101]:

In [101]:

In [101]: x = [1, 2, 3, 99, 99, 3, 2, 1]

In [102]: x1, x2, x3 = np.split(x, [3, 5])

In [103]: print(x1, x2, x3)
[1 2 3] [99 99] [3 2 1]

In [104]: grid = np.arange(16).reshape((4, 4))

In [105]: grid
Out[105]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

In [106]: upper,lower = np.vsplit(grid, [2])

In [107]: print(upper)
[[0 1 2 3]
 [4 5 6 7]]

In [108]: print(lower)
[[ 8  9 10 11]
 [12 13 14 15]]

In [109]: left, right = np.hsplit(grid, [2])

In [110]: print(left)
[[ 0  1]
 [ 4  5]
 [ 8  9]
 [12 13]]

In [111]: print(right)
[[ 2  3]
 [ 6  7]
 [10 11]
 [14 15]]

```

















